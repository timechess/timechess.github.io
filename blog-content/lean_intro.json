{
  "slug": "lean_intro",
  "content": "\nAs the first article of this series, we won't start from installation since it is non-trivial and may discourage readers. Luckily, we can use the [online version](https://live.lean-lang.org) of Lean 4 to get started. Although it still has some limitations compared to the local version, it will be enough to run the examples in this guide.\n\nThe last warning before we get started is that for those who have no experience of programming, some of the concepts may be hard to understand. I don't recommend taking this guide as a first step to learn programming, since Lean is a functional programming language that differs a lot from the common imperative programming languages such as C and Python. This guide can be minimal but not easy. Make sure you are prepared.\n\n# Types and Terms\n\nLean is an interactive theorem prover, which means you are constantly interacting with the language server while writing Lean code. The typical user interface of Lean includes a text editor and an infoview, where Lean provides structured information according to the position of the cursor. Now we introduce two basic commands, `#eval` and `#check`, to interact with Lean.\n\n`#eval` is used to evaluate the given expression. In other words, it can be used as a calculator. For example, we can evaluate the following expression:\n\n```lean\n#eval 1 + 2               -- 3\n#eval \"Hello \" ++ \"World\" -- \"Hello World\"\n#eval [1, 2] ++ [3, 4]    -- [1, 2, 3, 4]\n#eval true && false       -- false\n```\n\nThe infoview will display the evaluation results when you use the `#eval` command. If you try to evaluate some expressions that can not be displayed in the infoview, you will get a complicated error that we won't discuss here.\n\nYou may also notice that in the examples above, we tested four different operations, the addition of natural numbers, the concatenation of strings and lists, and the logical AND of boolean values. They are all functions that take two arguments and return values with the same type. Type is a key concepts in programming in Lean. Everything has a type. And an expression can be evaluated only when it passes the type checking.\n\nYou can use the command `#check` to see the type of an expression.\n\n```lean\n#check 1      --      1 : Nat\n#check true   --   true : Bool\n#check [1, 2] -- [1, 2] : List Nat\n#check Nat    --    Nat : Type\n```\n\nYou can observe that the numeric literal `1` has type `Nat`, and `Nat` has type `Type`. The colon is used to seperate value and type. We read `1 : Nat` as `1` has type `Nat`, or `1` is a term of type `Nat`. If you see colon in Lean, it always means the right-hand-side is the type of left-hand-side.\n\nWhen we `#check` the literals above, we didn't mark the type of them using colons, but Lean still knows their types. We are relying on the powerful **type inference** functionality of Lean. Modern programming languages such as Rust (and Lean of course) has the ability to infer a variable's type from the context. So we don't need to explicitly tell the compiler its type. You can move your cursor to the expression without type signature to see the type inferred by the compiler.\n\nFrom `Nat : Type` we know that the type of natural numbers also has a type, which is `Type`, the type of all concrete types. Moreover, `Type` also has type, which is `Type 1`. You can use `#check` to discover more.\n\nFunctions also have types. For example, a function that takes a `Nat` as argument and returns a `Nat` is of type `Nat -> Nat`. This right arrow `->` used to connected two types constructs a function type. You can also replace it with `→`, which can be typed using `\\to` in Lean's text editor. They are equivalent. You can use the keyword `fun` to construct a term of a function type. It's like `lambda` in Python.\n\n```lean\n#check fun (x : Nat) => x -- fun x => x : Nat -> Nat\n```\n\nNote that if you don't mark the type here, the infoview will display something like `fun x => x : ?m.986 → ?m.986`. That's because Lean can not infer the type of this function from the context, so it uses **metavariable** as a placeholder. They are variables waiting to be filled, or undetermined in the context. You can `#check` such kind of expression, but the compiler will produce errors if your real programs contain metavariables.\n\nYou can use the keyword `def` to introduce named variables to current environment. For example, you can define a function named `f` with type `Nat -> Nat -> Nat`.\n\n```lean\ndef f : Nat -> Nat -> Nat := fun x y => x + y\n```\n\nTo apply the function, use the syntax `func_name arg1 arg2 ...`.\n\n```lean\n#eval f 1 2 -- 3\n```\n\nIn the example above, the left-hand-side of symbol `:=` is the name and type signature of the variable, while the right-hand-side is the concrete value, or term, that satisfies the given type. After we write this `def` sentence and pass the check, we actually prove that there exists a term for type `Nat -> Nat -> Nat`. This perspective can help us understand the essence of theorem proving in Lean better.\n\n# Proposition as Types\n\nNow we will introduce a special kind of types.\n\n```lean\n#check 1 + 1 = 2                 --              1 + 1 = 2 : Prop\n#check ∀ (x : Nat), x ≥ 0        --     ∀ (x : Nat), x ≥ 0 : Prop\n#check ∃ x > 0, x < 2 → x = 1    -- ∃ x > 0, x < 2 → x = 1 : Prop\n#check Prop                      --                   Prop : Type\n```\n\nSince Lean is a theorem prover, we can write mathematical propositions in Lean. In the examples above, we can observe that the type of all concrete propostions is `Prop`, and the type of `Prop` is `Type`. These universal types, such as `Prop`, `Type`, `Type 1`, are called **Type Universe**. They can be sorted in a linear order.\n\n| Sort 0    | Sort 1 | Sort 2 | Sort 3 | ... |\n| --------- | ------ | ------ | ------ | --- |\n| Prop      | Type   | Type 1 | Type 2 | ... |\n| 1 + 1 = 2 | Nat    | Type   | Type 1 | ... |\n\n`Sort u` is equivalent with its corresponding item in the second row of this table, which means `Prop` is also `Sort 0`. They are just syntactically different. The third row contains example terms for the types.\n\nThen here comes the question: What is the term of a concrete proposition? The answer is its proof. Just like the example of defining functions in the previous section, proving a proposition is to construct a term of the given type. We are switching from the `Type` universe to the `Prop` universe.\n\nWe can still use the `def` keyword. But normally we use `theorem` to define variables with propositions as their types.\n\n```lean\ntheorem ex1 (p q : Prop) (hp : p) (hyp : p -> q) : q := sorry\n```\n\nIn the example above, we are moving the arguments to the left-hand-side of the colon. It still satisifes the basic rule that the right-hand-side is type of left-hand-side since `q` is the type of `ex1 p q hp hyp`. We use `sorry` as a placeholder to avoid errors. You will find the compiler complain in warnings that this declaration is using `sorry`. There is an axiom in Lean that enables `sorry` to be term of any type and proposition, but it is still fake proof and Lean knows that.\n\nYou will find it hard to give a type signature of `ex1` using the pattern described in previous section since the type of the third argument `hp` depends on `p`. Lean allows the following signature.\n\n```lean\ntheorem ex1 : (p q : Prop) -> p -> (p -> q) -> q := sorry\n```\n\nOr a preferred version in proposition style.\n\n```lean\ntheorem ex1 : ∀ (p q : Prop), p → (p → q) → q := sorry\n```\n\nThey are the same. And to construct terms of such type, you can view it as a function that takes the proofs of propostions and returns the proof of the target propostion.\n\n```lean\ntheorem ex1 (p q : Prop) (hp : p) (hyp : p -> q) : q := hyp hp\n```\n\nWe are actually meeting [Curry-Howard Correspondence](https://en.wikipedia.org/wiki/Curry%E2%80%93Howard_correspondence) here. But we won't explain it in detail. From the example above we can conclude that **theorems are functions** most of the time. Of course there exist theorems without any condition or hypothesis. For example, the ones with existential quantifiers.\n\n```lean\ntheorem ex2 : ∃ x : Nat, x > 1 := sorry\n```\n\nWe will discuss them in later articles.\n\n# Tactic Proof and Term Proof\n\nConstructing terms is easy to understand but hard in practice. For theorems in modern mathematics, it's nearly impossible to use this style of proof. Actually we are writing **term proof** in the example above, which is not the common way to write proofs in Lean. Instead, we will use pre-defined meta programs called **tactics** to help us construct proofs. Without tactics, Lean will lose all of its power and magics.\n\nWe use the keyword `by` to enter tactic mode when constructing terms.\n\n```lean\ntheorem ex1 (p q : Prop) (hp : p) (hyp : p -> q) : q := by\n  sorry\n```\n\nPut your cursor before `sorry` or after `by`, you can see the infoview showing tactic state.\n\n```lean\ntheorem ex1 (p q : Prop) (hp : p) (hyp : p -> q) : q := by\n  /-\n  p q : Prop\n  hp : p\n  hyp : p → q\n  ⊢ q\n  -/\n  sorry\n```\n\nThe tactic state, or proof state, shows all the hypotheses and variables you can use and the goal to prove. Note that everything in the `by` block should be a tactic, including `sorry`. The `sorry` here is different from the one we use above, which is a tactic not term.\n\nWe can use the simplest tactic `exact` to prove this theorem.\n\n```lean\ntheorem ex1 (p q : Prop) (hp : p) (hyp : p -> q) : q := by\n  exact hyp hp\n```\n\n`exact` just close the goal with the provided term. The whole proof is equivalent with the term proof in the example above. Actually, all the proofs of a proposition are equivalent in Lean. You can use `show_term` before `by` to see the term constructed by tactics. You will see a `TryThis` suggestion in the infoview.\n\n```lean\ntheorem ex1 (p q : Prop) (hp : p) (hyp : p -> q) : q := show_term by\n  -- Try this: hyp hp\n  exact hyp hp\n```\n\nClicking on the highlighted `hyp hp` will replace your tactic proof with this term proof.\n\nTactics are meta programs that can be created by the user to solve specific problems. Most of the intelligent tactics are defined in [Mathlib](https://github.com/leanprover-community/mathlib4), which is the mathematical standard library of Lean. It is not installed along with the toolchain for its huge size. Luckily, the online editor has Mathlib in its environment, so you can use tactics and theorems in Mathlib by adding `import Mathlib` at the top of the file.\n\nWe won't talk about how to write custom tactics in this guide. Please refer to [Metaprogramming in Lean 4](https://leanprover-community.github.io/lean4-metaprogramming-book/) for more information.\n\nYou will need to learn the usages of commonly used tactics if you want to prove something. In this guide we will only cover a small range of tactics, which is not enough for practioners. Please explore other materials after finishing this guide.\n",
  "title": "A Minimal Guide for Theorem Proving in Lean 4: Introduction of Basic Concepts",
  "date": "2025-7-17",
  "description": "In this article, we will go through the basic concepts of Lean 4 to understand the simplest proof.",
  "author": [
    "timechess"
  ],
  "tags": [
    "Lean"
  ],
  "draft": false,
  "navigation": {
    "prevPost": {
      "slug": "theoremforge",
      "title": "TheoremForge: A Blueprint Towards Autoformalization of Research-Level Mathematics",
      "description": "In this blog I will describe the blueprint of developing agentic systems for autoformalization of research-level mathematics."
    },
    "nextPost": null
  }
}